{
  "ziti/manage/pki.html": {
    "href": "ziti/manage/pki.html",
    "title": "Public Key Infrastructure (PKI) | NetFoundry Ziti",
    "keywords": "Public Key Infrastructure (PKI) All Ziti networks leverage Public Key Infrastructure (PKI) in order to provide a secure network. PKI is a complex topic and it is recommended to be familiar with what a PKI is and how to use and configure a PKI before making any decisions about the PKI the Ziti network uses. PKI Options Configuring the PKI for a Ziti network is often done using a self-signed certificate. The ziti command line utility provides a mechanism to create"
  },
  "ziti/services/creating.html": {
    "href": "ziti/services/creating.html",
    "title": "Creating an Identity | NetFoundry Ziti",
    "keywords": "Creating an Identity This is all about creating identities"
  },
  "ziti/docker-quickstart.html": {
    "href": "ziti/docker-quickstart.html",
    "title": "Ziti Quickstart | NetFoundry Ziti",
    "keywords": "Ziti Quickstart This guide will get you up and running with a demonstrable service in only a few minutes. If you are unfamiliar with the relevant ziti concepts refer to the overview . This guide will utilize docker to stand up a full and complete network. If you are unfamiliar with docker take a moment and follow along with the steps for installing and running an application on your operating system. Once you feel comfortable, proceed to the steps below. From Nothing to Network Obtain the software necessary to run a Ziti network. You will need"
  },
  "index.html": {
    "href": "index.html",
    "title": "Overview | NetFoundry Ziti",
    "keywords": "Overview Spin up your network with NetFoundry's Ziti. Getting Started If you're new to Ziti start here to get an overview of what Ziti is. Learn about the components that make up a Ziti-enabled Network and learn how to get a network running. Ziti SDKs Learn about the Ziti SDKs available to use and how to embed them into your own application to provide secure connectivity. Note This is a NOTE Warning This is a WARNING Tip This is a TIP Important This is IMPORTANT this is a cell this is a markdown test"
  },
  "ziti/appwans/creating.html": {
    "href": "ziti/appwans/creating.html",
    "title": "Creating an Identity | NetFoundry Ziti",
    "keywords": "Creating an Identity This is all about creating identities"
  },
  "ziti/clients/tunneler.html": {
    "href": "ziti/clients/tunneler.html",
    "title": "Tunnelers | NetFoundry Ziti",
    "keywords": "Tunnelers A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. NetFoundry provides tunnelers for each major operating system. Windows MacOS Linux Each tunneller operates similarly. The goal is to have the tunneler intercecpt traffic destined for Ziti services and forward that traffic over the Ziti overlay instead of the underlay network. There are two basic modes a tunneler operate in: seamless and proxy. A seamless tunneler will transparently intercept traffic via IPv4 address or DNS whereas a tunneler in proxy mode works as a proxy. Seamless mode is transparent to existing services and applications. Proxy mode is not as transparent at all. It requires applications to send traffic to the localhost proxy specifically. This means when running in proxy mode - it does not do any intercepting at all. Here you can learn about the ways each tunneler operates and see the similarities as well as any differences. Linux The linux tunneler is capable of operating in both transparent and proxy modes. In transparent mode the tunneler will interact with the operating system to establish intercept points. These intercept points correspond directly to the service definitions in place. ziti-tunnel supports several intercept modes, which are specified with a sub-command. Typically you will run ziti-tunnel with the run sub-command, which determines the preferred intercept mode based on the kernel drivers that are available on the host. $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33641 [ 0.006] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tproxy interceptor ... When started on a host that lacks iptables , the tproxy intercept mode initializer fails and ziti-tunnel attempts to use the tun intercept mode: $ sudo ziti-tunnel run ziti.json [ 0.001] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:37313 [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.009] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tun interceptor ziti-tunnel fails to start if no intercept modes can be successfully initialized: $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tun initialization failed: failed to open tun interface (name='', mtu=0): ioctl failed with 'invalid argument' [ 0.001] FATAL ziti/tunnel/cmd/ziti-tunnel/subcmd.run: failed to initialize an interceptor Intercept Modes tproxy tproxy is the preferred intercept mode when running on a Linux kernel that has the ip_tables kernel module installed. $ lsmod | grep ip_tables ip_tables 32768 5 iptable_filter,iptable_security,iptable_raw,iptable_nat,iptable_mangle ziti-tunnel manipulates routing tables and firewall rules when using the tproxy intercept mode. The NET_ADMIN Linux capability is required for these actions. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tproxy [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33355 [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.018] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.018] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.033] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.096] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.290] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.570] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding local.io = 169.254.1.1 to resolver The tproxy intercept mode creates a network listener that accepts connections at a randomly selected port on the loopback interface. Intercepted ziti service traffic directed to the listener by two mechanisms: Firewall Rules (iptables) The TPROXY iptables target is the primary intercept mechanism used by the tproxy intercept mode. The TPROXY target essentially sends packets to a local listener without actually modifying the packet's destination address fields. See https://www.kernel.org/doc/Documentation/networking/tproxy.txt and iptables-extensions(8) for more details on the TPROXY target. First, the tproxy interceptor links a new iptables chain to the PREROUTING chain: $ sudo iptables -nt mangle -L PREROUTING | grep NF-INTERCEPT NF-INTERCEPT all -- 0.0.0.0/0 0.0.0.0/0 Then it creates rules in the new chain for each intercepted service. You can view the tproxy rules in play: $ sudo iptables -nt mangle -L NF-INTERCEPT Chain NF-INTERCEPT (1 references) target prot opt source destination TPROXY tcp -- 0.0.0.0/0 5.9.243.187 /* wttr.in */ tcp dpt:443 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 169.254.1.1 /* ssh-local */ tcp dpt:22 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 1.2.3.4 /* netcat */ tcp dpt:22169 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 Packets with a destination address that matches the intercept address of a Ziti service are directed to ziti-tunnel's network listener (127.0.0.1:33355 in the examples above). This effectively enables ziti-tunnel to capture packets that are destined for any address using a single listener (and a single port). NOTE: netfilter rules were considered when implementing ziti-tunnel's tproxy intercept mode. netfilter is a slightly more modern than iptables and has a supported netlink API for manipulating rules without \"shelling out\" to the iptables command line utility. netfilter was ultimately abandoned because netfilter tproxy support requires kernel configuration options ( CONFIG_NFT_TPROXY , CONFIG_NFT_SOCKET ) that are not enabled in the default kernels of many common Linux distributions. Local Routes The TPROXY target is only valid in the PREROUTING iptables chain, which is traversed by incoming packets that were routed to the host over the network. A local route is necessary in order to get locally generated packets to traverse the PREROUTING chain: $ ip route show table local local 1.2.3.4 dev lo proto kernel scope host src 1.2.3.4 local 5.9.243.187 dev lo proto kernel scope host src 5.9.243.187 local 169.254.1.1 dev lo proto kernel scope host src 169.254.1.1 tun The tun intercept mode creates an ephemeral tun interface and configures it with the IP addresses of the services that are being proxied. ziti-tunnel manipulates network interfaces when using the tun intercept mode, which requires the NET_ADMIN Linux capability. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tun [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.012] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.012] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.031] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.089] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.280] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.502] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding myhost.io = 169.254.1.2 to resolver [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service ssh-local not hostable [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service netcat [ 2.506] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service netcat not hostable ... The addresses that ziti-tunnel adds to the tun interface are point-to-point addresses: $ ip addr show dev tun0 10: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 65535 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 169.254.1.1/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 5.9.243.187/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 169.254.1.2/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 1.2.3.4/32 scope host tun0 valid_lft forever preferred_lft forever The tun interface itself is assigned a link-local address, 169.254.1.1 in this case, and each intercepted service is represented by a point-to-point address with the remote address matching the intercept IP of the Ziti service. The tun intercept mode uses point-to-point addresses instead of local routes because local routes would result in the Linux networking stack receiving the packets that are routed to the tun interface. The point-to-point addresses ensure that the packets are delivered \"to the wire\", which mean that, for a tun interface, the packets will be picked up by ziti-tunnel when it reads data from the tun interface. proxy The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the edge controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN DNS Server ziti-tunnel runs an internal DNS server by default. The DNS server must be first in the host's resolver configuration (e.g. resolve.conf). A self-test is performed when ziti-tunnel starts to ensure that its internal DNS server is configured in the system resolver: INFO[0002] dns server started on 127.0.0.1:53 INFO[0002] adding ziti-tunnel.resolver.test -> 19.65.28.94 to resolver INFO[0002] removing ziti-tunnel.resolver.test from resolver The test involves inserting a known hostname/IP address into the internal DNS server, and using the system resolver to retrieve the address of the hostname. ziti-tunnel will exit if the DNS self-test fails. Linux distributions typically manage the contents of /etc/resolv.conf, so simply editing the file will only work for a short time until /etc/resolv.conf is overwritten by the managing process. Resolver configuration changes must survive restarts of the Linux name resolution manager. Linux distrubutions use one of several name resolution managers. The simplest way to determine which name resolution manager is being used by your Linux distrubtion is to look at /etc/resolv.conf: $ ls -l /etc/resolv.conf If /etc/resolv.conf is a regular file, then it is most likely being managed by dhclient . If /etc/resolv.conf is a symlink to a file in /run/systemd/resolve, then it is being managed by systemd-resolved dhclient If your Linux distribution uses dhclient, you can configure the system resolver to use ziti-tunnel's internal DNS server first by adding the following to /etc/dhcp/dhclient.conf: prepend domain-name-servers 127.0.0.1; Then restart network manager. Unless you know the name of the NetworkManager systemd service on your Linux distrubtion, it's probably easiest to reboot the host. systemd-resolved $ sudo ln -sf /run/systemd/resolve/resolv.conf /etc $ echo -e \"[Resolve]\\nDNS=127.0.0.1\" | sudo tee /etc/systemd/resolved.conf.d/ziti-tunnel.conf $ sudo systemctl restart systemd-resolved If you are unable to control the resolver on your operating system, ziti-tunnel can use/update a hosts file for any hostnames that it tunnels: ziti-tunnel run --resolver file:///etc/hosts \"${HOME}/ziti.json\" IP Address Assignment If the service specifies a hostname for its address, ziti-tunnel resolves the hostname and adds the result to its internal DNS server: [0127] INFO adding myservice.mydomain.com -> 45.60.32.165 to resolver If the service hostname does not resolve, ziti-tunnel will find an unused link-local address and assign it to the route for the service: [0012] INFO adding bogushost.net -> 169.254.1.4 to resolver [0012] INFO ziti/tunnel/protocols/tcp.Listen: Accepting on 169.254.1.4:25 service=telnet Windows The Windows tunneler currently supports proxy mode and cannot yet seamlessly intercept IPv4 traffic/DNS requests. The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the edge controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN Android The Android tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months. iOS The iOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months. MacOS The MacOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "ziti/clients/linux.html": {
    "href": "ziti/clients/linux.html",
    "title": "Linux | NetFoundry Ziti",
    "keywords": "Linux The linux tunneler is capable of operating in both transparent and proxy modes. In transparent mode the tunneler will interact with the operating system to establish intercept points. These intercept points correspond directly to the service definitions in place. ziti-tunnel supports several intercept modes, which are specified with a sub-command. Typically you will run ziti-tunnel with the run sub-command, which determines the preferred intercept mode based on the kernel drivers that are available on the host. $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33641 [ 0.006] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tproxy interceptor ... When started on a host that lacks iptables , the tproxy intercept mode initializer fails and ziti-tunnel attempts to use the tun intercept mode: $ sudo ziti-tunnel run ziti.json [ 0.001] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:37313 [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.009] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tun interceptor ziti-tunnel fails to start if no intercept modes can be successfully initialized: $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tun initialization failed: failed to open tun interface (name='', mtu=0): ioctl failed with 'invalid argument' [ 0.001] FATAL ziti/tunnel/cmd/ziti-tunnel/subcmd.run: failed to initialize an interceptor Intercept Modes tproxy tproxy is the preferred intercept mode when running on a Linux kernel that has the ip_tables kernel module installed. $ lsmod | grep ip_tables ip_tables 32768 5 iptable_filter,iptable_security,iptable_raw,iptable_nat,iptable_mangle ziti-tunnel manipulates routing tables and firewall rules when using the tproxy intercept mode. The NET_ADMIN Linux capability is required for these actions. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tproxy [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33355 [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.018] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.018] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.033] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.096] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.290] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.570] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding local.io = 169.254.1.1 to resolver The tproxy intercept mode creates a network listener that accepts connections at a randomly selected port on the loopback interface. Intercepted ziti service traffic directed to the listener by two mechanisms: Firewall Rules (iptables) The TPROXY iptables target is the primary intercept mechanism used by the tproxy intercept mode. The TPROXY target essentially sends packets to a local listener without actually modifying the packet's destination address fields. See https://www.kernel.org/doc/Documentation/networking/tproxy.txt and iptables-extensions(8) for more details on the TPROXY target. First, the tproxy interceptor links a new iptables chain to the PREROUTING chain: $ sudo iptables -nt mangle -L PREROUTING | grep NF-INTERCEPT NF-INTERCEPT all -- 0.0.0.0/0 0.0.0.0/0 Then it creates rules in the new chain for each intercepted service. You can view the tproxy rules in play: $ sudo iptables -nt mangle -L NF-INTERCEPT Chain NF-INTERCEPT (1 references) target prot opt source destination TPROXY tcp -- 0.0.0.0/0 5.9.243.187 /* wttr.in */ tcp dpt:443 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 169.254.1.1 /* ssh-local */ tcp dpt:22 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 1.2.3.4 /* netcat */ tcp dpt:22169 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 Packets with a destination address that matches the intercept address of a Ziti service are directed to ziti-tunnel's network listener (127.0.0.1:33355 in the examples above). This effectively enables ziti-tunnel to capture packets that are destined for any address using a single listener (and a single port). NOTE: netfilter rules were considered when implementing ziti-tunnel's tproxy intercept mode. netfilter is a slightly more modern than iptables and has a supported netlink API for manipulating rules without \"shelling out\" to the iptables command line utility. netfilter was ultimately abandoned because netfilter tproxy support requires kernel configuration options ( CONFIG_NFT_TPROXY , CONFIG_NFT_SOCKET ) that are not enabled in the default kernels of many common Linux distributions. Local Routes The TPROXY target is only valid in the PREROUTING iptables chain, which is traversed by incoming packets that were routed to the host over the network. A local route is necessary in order to get locally generated packets to traverse the PREROUTING chain: $ ip route show table local local 1.2.3.4 dev lo proto kernel scope host src 1.2.3.4 local 5.9.243.187 dev lo proto kernel scope host src 5.9.243.187 local 169.254.1.1 dev lo proto kernel scope host src 169.254.1.1 tun The tun intercept mode creates an ephemeral tun interface and configures it with the IP addresses of the services that are being proxied. ziti-tunnel manipulates network interfaces when using the tun intercept mode, which requires the NET_ADMIN Linux capability. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tun [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.012] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.012] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.031] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.089] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.280] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.502] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding myhost.io = 169.254.1.2 to resolver [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service ssh-local not hostable [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service netcat [ 2.506] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service netcat not hostable ... The addresses that ziti-tunnel adds to the tun interface are point-to-point addresses: $ ip addr show dev tun0 10: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 65535 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 169.254.1.1/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 5.9.243.187/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 169.254.1.2/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 1.2.3.4/32 scope host tun0 valid_lft forever preferred_lft forever The tun interface itself is assigned a link-local address, 169.254.1.1 in this case, and each intercepted service is represented by a point-to-point address with the remote address matching the intercept IP of the Ziti service. The tun intercept mode uses point-to-point addresses instead of local routes because local routes would result in the Linux networking stack receiving the packets that are routed to the tun interface. The point-to-point addresses ensure that the packets are delivered \"to the wire\", which mean that, for a tun interface, the packets will be picked up by ziti-tunnel when it reads data from the tun interface. proxy The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the edge controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN DNS Server ziti-tunnel runs an internal DNS server by default. The DNS server must be first in the host's resolver configuration (e.g. resolve.conf). A self-test is performed when ziti-tunnel starts to ensure that its internal DNS server is configured in the system resolver: INFO[0002] dns server started on 127.0.0.1:53 INFO[0002] adding ziti-tunnel.resolver.test -> 19.65.28.94 to resolver INFO[0002] removing ziti-tunnel.resolver.test from resolver The test involves inserting a known hostname/IP address into the internal DNS server, and using the system resolver to retrieve the address of the hostname. ziti-tunnel will exit if the DNS self-test fails. Linux distributions typically manage the contents of /etc/resolv.conf, so simply editing the file will only work for a short time until /etc/resolv.conf is overwritten by the managing process. Resolver configuration changes must survive restarts of the Linux name resolution manager. Linux distrubutions use one of several name resolution managers. The simplest way to determine which name resolution manager is being used by your Linux distrubtion is to look at /etc/resolv.conf: $ ls -l /etc/resolv.conf If /etc/resolv.conf is a regular file, then it is most likely being managed by dhclient . If /etc/resolv.conf is a symlink to a file in /run/systemd/resolve, then it is being managed by systemd-resolved dhclient If your Linux distribution uses dhclient, you can configure the system resolver to use ziti-tunnel's internal DNS server first by adding the following to /etc/dhcp/dhclient.conf: prepend domain-name-servers 127.0.0.1; Then restart network manager. Unless you know the name of the NetworkManager systemd service on your Linux distrubtion, it's probably easiest to reboot the host. systemd-resolved $ sudo ln -sf /run/systemd/resolve/resolv.conf /etc $ echo -e \"[Resolve]\\nDNS=127.0.0.1\" | sudo tee /etc/systemd/resolved.conf.d/ziti-tunnel.conf $ sudo systemctl restart systemd-resolved If you are unable to control the resolver on your operating system, ziti-tunnel can use/update a hosts file for any hostnames that it tunnels: ziti-tunnel run --resolver file:///etc/hosts \"${HOME}/ziti.json\" IP Address Assignment If the service specifies a hostname for its address, ziti-tunnel resolves the hostname and adds the result to its internal DNS server: [0127] INFO adding myservice.mydomain.com -> 45.60.32.165 to resolver If the service hostname does not resolve, ziti-tunnel will find an unused link-local address and assign it to the route for the service: [0012] INFO adding bogushost.net -> 169.254.1.4 to resolver [0012] INFO ziti/tunnel/protocols/tcp.Listen: Accepting on 169.254.1.4:25 service=telnet"
  },
  "ziti/clients/proxy-example.html": {
    "href": "ziti/clients/proxy-example.html",
    "title": "| NetFoundry Ziti",
    "keywords": "The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the edge controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN"
  },
  "ziti/clients/windows.html": {
    "href": "ziti/clients/windows.html",
    "title": "Windows | NetFoundry Ziti",
    "keywords": "Windows The Windows tunneler currently supports proxy mode and cannot yet seamlessly intercept IPv4 traffic/DNS requests. The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the edge controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN"
  },
  "api/csharp/NetFoundry.ZitiIdentity.html": {
    "href": "api/csharp/NetFoundry.ZitiIdentity.html",
    "title": "Class ZitiIdentity | NetFoundry Ziti",
    "keywords": "Class ZitiIdentity Represents an enrolled identity Inheritance System.Object ZitiIdentity Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiIdentity Constructors | Improve this Doc ZitiIdentity(String) Creates a new ZitiIdentity using the provided path. The path must point at a file is the result of the enrollment process. Declaration public ZitiIdentity(string path) Parameters Type Name Description System.String path The path to the enrolled Ziti identity | Improve this Doc ZitiIdentity(String, Int32) Creates a new ZitiIdentity with the provided timeout (ms) using the provided path. The path must point at a file is the result of the enrollment process. Declaration public ZitiIdentity(string path, int timeOutInMillis) Parameters Type Name Description System.String path The path to the enrolled ziti identity System.Int32 timeOutInMillis timeout in milliseconds Properties | Improve this Doc PathToConfigFile The path to the enrolled identity Declaration public string PathToConfigFile { get; } Property Value Type Description System.String Methods | Improve this Doc Dump() Dumps debug information to standard out. Only used when debugging Declaration public void Dump() | Improve this Doc InitializeAndRun() Initializes this identity with the NetFoundry network Declaration public void InitializeAndRun() Exceptions Type Condition System.Exception Thrown when the path to the configuration file no longer exists or if the provided identity file is not valid | Improve this Doc NewConnection(String) Creates a new ZitiConnection for this identity Declaration public ZitiConnection NewConnection(string serviceName) Parameters Type Name Description System.String serviceName The service name to create a ZitiConnection for Returns Type Description ZitiConnection A ZitiConnection that is ready to be Dialed or converted to a stream via AsStream() Exceptions Type Condition ZitiException Thrown when the serviceName provided does not exist | Improve this Doc ServiceAvailable(String) Determines if the provided serviceName is available for this identity Declaration public bool ServiceAvailable(string serviceName) Parameters Type Name Description System.String serviceName The service name to verify Returns Type Description System.Boolean If the service exists - true, false if not | Improve this Doc Shutdown() instructs this identity to disconnect from the NetFoundry network Declaration public void Shutdown()"
  },
  "api/csharp/NetFoundry.ZitiConnection.OnDataWritten.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnDataWritten.html",
    "title": "Delegate ZitiConnection.OnDataWritten | NetFoundry Ziti",
    "keywords": "Delegate ZitiConnection.OnDataWritten A delegate that is invoked after data has been put into the event loop. If there are any expensive resources held this is the callback to release those resources. Only needed when not using Ziti as a System.IO.Stream (callback based Ziti) Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnDataWritten(ZitiStatus status, int bytesWritten, object context); Parameters Type Name Description ZitiStatus status A ZitiStatus that represents the state of the connection which initiated this callback. If NOT OK appropriate actions should be taken System.Int32 bytesWritten A count of how many bytes were able to be written. System.Object context The context that was supplied during the Write(Byte[], Int32, ZitiConnection.OnDataWritten, Object) invocation"
  },
  "ziti/clients/android.html": {
    "href": "ziti/clients/android.html",
    "title": "Android | NetFoundry Ziti",
    "keywords": "Android The Android tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Here you will find the information necessary to successfully use a Ziti SDK to create an application. If there is a term which is not familiar please refer to the glossary . Each SDK has certain syntax unique to the particular language the SDK is targetting. Each SDK presents an api which is as idomatic as possible to present a consistent look and feel for the language or runtime being used."
  },
  "api/csharp/NetFoundry.ZitiConnection.OnConnected.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnConnected.html",
    "title": "Delegate ZitiConnection.OnConnected | NetFoundry Ziti",
    "keywords": "Delegate ZitiConnection.OnConnected A delegate that represents the work to be done after a Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) operation. The result of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) may NOT be successful. It is important to verify the result by checking status Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnConnected(ZitiConnection zitiConnection, ZitiStatus status); Parameters Type Name Description ZitiConnection zitiConnection The ZitiConnection which as passed to the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) method ZitiStatus status The ZitiStatus representing the outcome of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived)"
  },
  "api/csharp/NetFoundry.ZitiStream.html": {
    "href": "api/csharp/NetFoundry.ZitiStream.html",
    "title": "Class ZitiStream | NetFoundry Ziti",
    "keywords": "Class ZitiStream A representation of a standard System.IO.Stream which utilizes the NetFoundry network Inheritance System.Object System.MarshalByRefObject System.IO.Stream ZitiStream Implements System.IDisposable Inherited Members System.IO.Stream.Null System.IO.Stream.BeginRead(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object) System.IO.Stream.BeginWrite(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object) System.IO.Stream.Close() System.IO.Stream.CopyTo(System.IO.Stream) System.IO.Stream.CopyTo(System.IO.Stream, System.Int32) System.IO.Stream.CopyToAsync(System.IO.Stream) System.IO.Stream.CopyToAsync(System.IO.Stream, System.Int32) System.IO.Stream.CopyToAsync(System.IO.Stream, System.Int32, System.Threading.CancellationToken) System.IO.Stream.CreateWaitHandle() System.IO.Stream.Dispose() System.IO.Stream.EndRead(System.IAsyncResult) System.IO.Stream.EndWrite(System.IAsyncResult) System.IO.Stream.FlushAsync() System.IO.Stream.FlushAsync(System.Threading.CancellationToken) System.IO.Stream.ObjectInvariant() System.IO.Stream.ReadAsync(System.Byte[], System.Int32, System.Int32) System.IO.Stream.ReadAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken) System.IO.Stream.ReadByte() System.IO.Stream.Synchronized(System.IO.Stream) System.IO.Stream.WriteAsync(System.Byte[], System.Int32, System.Int32) System.IO.Stream.WriteAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken) System.IO.Stream.WriteByte(System.Byte) System.IO.Stream.CanTimeout System.IO.Stream.ReadTimeout System.IO.Stream.WriteTimeout System.MarshalByRefObject.GetLifetimeService() System.MarshalByRefObject.InitializeLifetimeService() System.MarshalByRefObject.MemberwiseClone(System.Boolean) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiStream : Stream, IDisposable Constructors | Improve this Doc ZitiStream(ZitiConnection) Creates a ZitiStream from the provided ZitiConnection Declaration public ZitiStream(ZitiConnection conn) Parameters Type Name Description ZitiConnection conn The ZitiConnection to create a ZitiStream from Properties | Improve this Doc CanRead Indicates if the stream can be read from Declaration public override bool CanRead { get; } Property Value Type Description System.Boolean Overrides System.IO.Stream.CanRead | Improve this Doc CanSeek Seeking is not supported Declaration public override bool CanSeek { get; } Property Value Type Description System.Boolean Overrides System.IO.Stream.CanSeek | Improve this Doc CanWrite indicates if the stream is ready for writing Declaration public override bool CanWrite { get; } Property Value Type Description System.Boolean Overrides System.IO.Stream.CanWrite | Improve this Doc Length unsupported - always returns 0 Declaration public override long Length { get; } Property Value Type Description System.Int64 Overrides System.IO.Stream.Length | Improve this Doc Position unsupported - always returns 0 Declaration public override long Position { get; set; } Property Value Type Description System.Int64 Overrides System.IO.Stream.Position Exceptions Type Condition System.NotImplementedException Thrown when calling set Methods | Improve this Doc Dispose(Boolean) Disposes of the ZitiStream , cleaning up any retained resources Declaration protected override void Dispose(bool disposing) Parameters Type Name Description System.Boolean disposing Overrides System.IO.Stream.Dispose(System.Boolean) | Improve this Doc Flush() Flushes bytes Declaration public override void Flush() Overrides System.IO.Stream.Flush() | Improve this Doc PumpAsync(Stream) Asynchronously pumps this ZitiStream to/from the destination System.IO.Stream Declaration public Task PumpAsync(Stream destination) Parameters Type Name Description System.IO.Stream destination Returns Type Description System.Threading.Tasks.Task | Improve this Doc PumpAsync(Stream, Stream) Asynchronously pumps data between the input System.IO.Stream and destination System.IO.Stream Declaration public static Task PumpAsync(Stream input, Stream destination) Parameters Type Name Description System.IO.Stream input The input stream System.IO.Stream destination The destination stream Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task which is awaitable | Improve this Doc Read(Byte[], Int32, Int32) Reads data into the provided buffer Declaration public override int Read(byte[] buffer, int offset, int count) Parameters Type Name Description System.Byte [] buffer The buffer to read data into System.Int32 offset The position in the bufer to begin appending data System.Int32 count The number of bytes to append Returns Type Description System.Int32 Returns the number of bytes read Overrides System.IO.Stream.Read(System.Byte[], System.Int32, System.Int32) Exceptions Type Condition System.NotSupportedException Thrown if the stream is not ready for reading System.ArgumentNullException Thrown if the buffer provided is null System.ArgumentException Thrown if the offset and count provided is larger than the buffer provided System.ArgumentOutOfRangeException Thrown if the offset or count provided is less than 0 | Improve this Doc Seek(Int64, SeekOrigin) unsupported Declaration public override long Seek(long offset, SeekOrigin origin) Parameters Type Name Description System.Int64 offset System.IO.SeekOrigin origin Returns Type Description System.Int64 Overrides System.IO.Stream.Seek(System.Int64, System.IO.SeekOrigin) | Improve this Doc SetLength(Int64) unsupported Declaration public override void SetLength(long value) Parameters Type Name Description System.Int64 value Overrides System.IO.Stream.SetLength(System.Int64) | Improve this Doc Write(Byte[], Int32, Int32) Writes the provided buffer over the ZitiNetwork Declaration public override void Write(byte[] buffer, int offset, int count) Parameters Type Name Description System.Byte [] buffer The buffer containing data to write System.Int32 offset The position in the buffer to read from System.Int32 count The number of bytes to write from the buffer Overrides System.IO.Stream.Write(System.Byte[], System.Int32, System.Int32) Exceptions Type Condition System.NotSupportedException Thrown if the stream is not ready for writing System.ArgumentNullException Thrown if the buffer provided is null System.ArgumentException Thrown if the offset and count provided is larger than the buffer provided System.ArgumentOutOfRangeException Thrown if the offset or count provided is less than 0 Implements System.IDisposable"
  },
  "api/csharp/NetFoundry.ZitiConnection.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.html",
    "title": "Class ZitiConnection | NetFoundry Ziti",
    "keywords": "Class ZitiConnection Represents a connection through the Ziti network. Supports both System.IO.Stream use-cases as well as callback-based. Inheritance System.Object ZitiConnection Implements System.IDisposable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiConnection : IDisposable Methods | Improve this Doc Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) Establishes the necessary connecctivity and callbacks to send data through the NetFoundry network Declaration public void Dial(ZitiConnection.OnConnected onConnected, ZitiConnection.OnDataReceived onDataReceived) Parameters Type Name Description ZitiConnection.OnConnected onConnected Once the connection is established this callback is called ZitiConnection.OnDataReceived onDataReceived Called each time data is received over the NetFoundry network Exceptions Type Condition System.InvalidOperationException Thrown when the ZitiConnection has had AsStream invoked previously | Improve this Doc Dispose() Closes the ZitiConnection and cleans up as needed Declaration public void Dispose() | Improve this Doc Write(Byte[], Int32, ZitiConnection.OnDataWritten, Object) Writes the provided data over the NetFoundry network Declaration public void Write(byte[] data, int count, ZitiConnection.OnDataWritten onDataWritten, object context) Parameters Type Name Description System.Byte [] data A buffer holding the information to be sent over the NetFoundry network System.Int32 count How many bytes of the buffer (starting at position 0) to write ZitiConnection.OnDataWritten onDataWritten A callback to be invoked after the data is written to the NetFoundry network System.Object context Any object, provided back to the caller of this functionin the onDataWritten callback Implements System.IDisposable"
  },
  "samples/clang.html": {
    "href": "samples/clang.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "ziti/manage/tunneler.html": {
    "href": "ziti/manage/tunneler.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "api/clang/index.html": {
    "href": "api/clang/index.html",
    "title": "C Land SDK | NetFoundry Ziti",
    "keywords": "C Land SDK this is the landing page for c"
  },
  "ziti/appwans.html": {
    "href": "ziti/appwans.html",
    "title": "| NetFoundry Ziti",
    "keywords": "This is all about appwans"
  },
  "samples/index.html": {
    "href": "samples/index.html",
    "title": "SDK Sample Usage | NetFoundry Ziti",
    "keywords": "SDK Sample Usage Here you'll find the samples we have produced to try to illustrate how to use the SDKs. Demo Weather C C# CLANG example is available here: https://github.com/nf-dev/ziti-sdk-c/tree/master/programs/sample_wttr/ /* Copyright 2019 Netfoundry, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ #include <nf/ziti.h> #include <string.h> #include <stdlib.h> #include <stdio.h> #include <uv.h> #define DIE(v) do { \\ int code = (v);\\ if (code != ZITI_OK) {\\ fprintf(stderr, \"ERROR: \" #v \" => %s\\n\", ziti_errorstr(code));\\ exit(code);\\ }} while(0) static size_t total; static nf_context nf; void on_data(nf_connection c, uint8_t *buf, int len) { if (len == ZITI_EOF) { printf(\"request completed: %s\\n\", ziti_errorstr(len)); NF_close(&c); NF_shutdown(nf); } else if (len < 0) { fprintf(stderr, \"unexpected error: %s\\n\", ziti_errorstr(len)); NF_close(&c); NF_shutdown(nf); } else { total += len; printf(\"%*.*s\", len, len, buf); } } static void on_write(nf_connection conn, ssize_t status, void *ctx) { if (status < 0) { fprintf(stderr, \"request failed to submit status[%zd]: %s\\n\", status, ziti_errorstr(status)); } else { printf(\"request success: %zd bytes sent\\n\", status); } } void on_connect(nf_connection conn, int status) { DIE(status); printf(\"sending HTTP request\\n\"); uint8_t *req = \"GET /Rochester HTTP/1.0\\r\\n\" \"Accept: */*\\r\\n\" \"Connection: close\\r\\n\" \"Host: wttr.in\\r\\n\" \"User-Agent: curl/7.59.0\\r\\n\" \"\\r\\n\"; DIE(NF_write(conn, req, strlen(req), on_write, NULL)); } void on_nf_init(nf_context _nf, int status, void* ctx) { DIE(status); nf = _nf; nf_connection conn; DIE(NF_conn_init(nf, &conn, NULL)); DIE(NF_dial(conn, \"demo-weather\", on_connect, on_data)); } int main(int argc, char** argv) { #if _WIN32 //changes the output to UTF-8 so that the windows output looks correct and not all jumbly SetConsoleOutputCP(65001); #endif int res; uv_loop_t *loop = uv_default_loop(); DIE(NF_init(argv[1], loop, on_nf_init, NULL)); // loop will finish afger the request is complete and NF_shutdown is called uv_run(loop, UV_RUN_DEFAULT); printf(\"========================\\n\"); NF_free(&nf); } C# Example is available here: https://github.com/nf-dev/ziti-sdk-csharp/tree/initial_commit/Ziti.Core.Console using System; using System.IO; using System.Text; using System.Threading.Tasks; using NetFoundry; namespace Ziti.Core.Example { class Program { static async Task Main(string[] args) { byte[] wttrRequestAsBytes = Encoding.UTF8.GetBytes(\"GET / HTTP/1.0\\r\\n\" + \"Accept: *-/*\\r\\n\" + \"Connection: close\\r\\n\" + \"User-Agent: curl/7.59.0\\r\\n\" + \"Host: wttr.in\\r\\n\" + \"\\r\\n\"); string path = @\"c:/path/to/enrolled.id.json\"; //makes the output pretty - and not jumbly Console.OutputEncoding = Encoding.UTF8; /* Only needed when debugging Environment.SetEnvironmentVariable(\"ZITI_LOG\", \"6\"); NetFoundry.Ziti.OutputDebugInformation = true; */ ZitiIdentity id = new ZitiIdentity(path); id.InitializeAndRun(); //connect to the Ziti network //make a new stream using the identity ZitiStream zitiStream = new ZitiStream(id.NewConnection(\"demo-weather\")); //send the reqeust await zitiStream.WriteAsync(wttrRequestAsBytes, 0, wttrRequestAsBytes.Length); using (MemoryStream ms = new MemoryStream()) using (StreamReader sr = new StreamReader(ms)) { //display the bytes by reading from the stream and writing to the console await LocalPumpAsync(zitiStream, System.Console.OpenStandardOutput()); string output = sr.ReadToEnd(); System.Diagnostics.Debug.WriteLine(output); } } private const int DefaultStreamPumpBufferSize = 64 * 1024; public static async Task LocalPumpAsync(Stream input, Stream destination) { int count = DefaultStreamPumpBufferSize; byte[] buffer = new byte[count]; int numRead = await input.ReadAsync(buffer, 0, count).ConfigureAwait(false); while (numRead > 0) { destination.Write(buffer, 0, numRead); //writes are synchronous for now - without syncronous writes there's a lock that's //not freeing up //await destination.WriteAsync(buffer, 0, numRead).ConfigureAwait(false); numRead = await input.ReadAsync(buffer, 0, count).ConfigureAwait(false); } } } }"
  },
  "ziti/index.html": {
    "href": "ziti/index.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Here is the ziti/index file"
  },
  "ziti/identities.html": {
    "href": "ziti/identities.html",
    "title": "| NetFoundry Ziti",
    "keywords": "This is all about IDENT-ITIES"
  },
  "ziti/hello-ziti.html": {
    "href": "ziti/hello-ziti.html",
    "title": "| NetFoundry Ziti",
    "keywords": "If you are seeing this - you have successfully connected to a Ziti network!"
  },
  "api/csharp.html": {
    "href": "api/csharp.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "ziti/install/controller.html": {
    "href": "ziti/install/controller.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Hi from the controller file configuration: what does the version mean in config file configuration: why is there a 'db' in the config and why isn't it postgres configuration: logging explain - level/format control section:"
  },
  "ziti/manage/troubleshooting.html": {
    "href": "ziti/manage/troubleshooting.html",
    "title": "Troubleshooting | NetFoundry Ziti",
    "keywords": "Troubleshooting This is where we'll be doing troubleshooting"
  },
  "ziti/manage/manage.html": {
    "href": "ziti/manage/manage.html",
    "title": "| NetFoundry Ziti",
    "keywords": "this is the manage file"
  },
  "test.html": {
    "href": "test.html",
    "title": "this is a markdown test | NetFoundry Ziti",
    "keywords": "this is a markdown test"
  },
  "samples/csharp.html": {
    "href": "samples/csharp.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "glossary/glossary.html": {
    "href": "glossary/glossary.html",
    "title": "Glossary | NetFoundry Ziti",
    "keywords": "Glossary Here you will find a list of terms you may come across as you are using Ziti. Ziti Network, Ziti Ziti is a modern, programmable network overlay with associated edge components, for application-embedded, zero trust network connectivity, written by developers for developers. Ziti is NetFoundry's next-generation programmable networking product. Ziti is used to create Ziti Networks. Network Overlay, Overlay A Ziti network is implemented as an \"overlay\". A network overlay abstracts away the layers beneath it, providing a new set of abstractions for designing and implementing software and systems. Good programming abstractions allow developers to focus on the rules implemented by those abstractions without being concerned with the layers below the abstraction. Ziti's overlay allows developers to focus on connectivity between components without having to be concerned with low-level details of how that connectivity is managed. Underlay We refer to lower-level network concerns as \"underlay\". IP networking would be an example of an underlay concept. Ziti Fabric, Fabric The Ziti Fabric provides the core of the network overlay. The Ziti Fabric implements a routable mesh network, which can provide reliable connectivity between any two points on the network. The fabric provides software extension mechanisms that allow the overlay to be embedded into new overlay applications. The Ziti Edge is an example of an overlay application implemented on top of Ziti Fabric extension mechanisms (Xgress, Xctrl, Xmgmt). Ziti Router, Router A Ziti Router is a process that is installed on a host, which allows it to participate in a Ziti Fabric. The router is designed to be extensible through Ziti fabric extension mechanisms (Xgress), which means that it is capable of \"hosting\" overlay network applications like the Ziti Edge. Ziti Controller, Controller A Ziti Controller is a process that is installed on a host, which allows it to coordinate a Ziti network. The controller is designed to be extensible through Ziti fabric extension mechanisms (Xctrl, Xmgmt), which means that it is capable of hosting extensions to the fabric control and management planes. Xgress (Xctrl, Xmgmt), Ziti Fabric SDK Xgress is a set of extension components for the Ziti fabric, which enable overlay applications to participate in the overlay network. Xgress focuses on extending the data plane, providing interfaces for creating initiating and terminating endpoints. Xctrl and Xmgmt focus on extending the control and management planes of the fabric. Xgress is the core of the Ziti Fabric SDK. Ziti Edge, Edge The Ziti Edge implements the zero trust connectivity framework as an overlay application on top of the Ziti Fabric. The Ziti Edge provides connectivity implementations for a number of important endpoint types, including applications that embed Ziti connectivity through the Ziti Edge SDK. The Ziti Edge provides fallback connectivity solutions for non-Ziti applications using components like the Ziti tunnelers, and the Ziti proxy. Ziti Endpoint SDK, Endpoint SDK, SDK The Ziti Endpoint SDK provides software components that are designed to be embedded into customer applications so that they can participate natively in a Ziti network. The SDK targets golang, Swift, C, C#, and potentially other programming languages, allowing programs in those languages to work with idioms and concepts native to those environments. The SDK provides support for both accessing and hosting services that are available on a Ziti network. Ziti Enabled Application A Ziti Enabled Application is an application that embeds the Ziti Endpoint SDK, such that it can participate on a Ziti network to either access or host services. Ziti Tunneler, Tunneler A Ziti Tunneler provides connectivity for applications that are not Ziti enabled. Our tunneler implementations provide an underlay connectivity component (TUN, tproxy, etc.), and then use the Ziti Endpoint SDK such that they can bridge connectivity onto the Ziti network. Ziti Service, Service A Ziti network is primarily concerned with providing access to \"services\". A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. A Ziti Service is defined by a strong, extensible identity, rather than by an expression of an underlay concept. This means that services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti service would be defined by a name and/or a certificate, rather than by a DNS name or an IP address (underlay concepts). Service Definition A service definition is used to \"bind\" a service to a specific underlay network expression, through one or more nodes on a Ziti overlay network. A service definition usually includes a terminating router (or routers) and one or more SDK or underlay network endpoints where the service can be reached. Session A session is an \"instance\" of a service on behalf of an initiating endpoint, which is connected to a terminating endpoint. A session has strong identity and security between the initiating endpoint, terminating endpoint, and throughout the links between. A session selects a specific set of routers to traverse between the endpoints, and that path can change dynamically due to network performance. Initiating Router, Terminating Router An initiating router is the router which initiates a request for a session on behalf of a connected endpoint. A terminating router is the router which provides access to the service associated with the session request. Every session links an initiating endpoint (through an initiating router), with a terminating endpoint (through a terminating router). Initiating Endpoint, Terminating Endpoint See \"initiating router\" and \"terminating router\" above. The initiating endpoint is the endpoint responsible for requesting connectivity to a service. The terminating endpoint is the endpoint that provides the service. Path The path is the set of Ziti Routers traversed by a session from an initiating router to a terminating router. Ziti aggressively optimizes the path for throughput and reliability, and so it may change during the session."
  },
  "api/csharp/NetFoundry.html": {
    "href": "api/csharp/NetFoundry.html",
    "title": "Namespace NetFoundry | NetFoundry Ziti",
    "keywords": "Namespace NetFoundry Classes Ziti A collection of static helper methods and properties for Ziti. ZitiConnection Represents a connection through the Ziti network. Supports both System.IO.Stream use-cases as well as callback-based. ZitiException Represents a Ziti-specific exception ZitiIdentity Represents an enrolled identity ZitiStream A representation of a standard System.IO.Stream which utilizes the NetFoundry network Enums ZitiStatus An enum representing the outcome of the given Ziti operation. Delegates ZitiConnection.OnConnected A delegate that represents the work to be done after a Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) operation. The result of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) may NOT be successful. It is important to verify the result by checking status ZitiConnection.OnDataReceived A delegate that represents the work to be done when data is recieved over the Ziti network. Only invoked after a successful Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) . Each time data is received it is important to verify the status is still OK ZitiConnection.OnDataWritten A delegate that is invoked after data has been put into the event loop. If there are any expensive resources held this is the callback to release those resources. Only needed when not using Ziti as a System.IO.Stream (callback based Ziti)"
  },
  "api/clang.html": {
    "href": "api/clang.html",
    "title": "| NetFoundry Ziti",
    "keywords": "This is the c# sdk"
  },
  "api/csharp/NetFoundry.ZitiConnection.OnDataReceived.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnDataReceived.html",
    "title": "Delegate ZitiConnection.OnDataReceived | NetFoundry Ziti",
    "keywords": "Delegate ZitiConnection.OnDataReceived A delegate that represents the work to be done when data is recieved over the Ziti network. Only invoked after a successful Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) . Each time data is received it is important to verify the status is still OK Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnDataReceived(ZitiStatus status, byte[] data, int count); Parameters Type Name Description ZitiStatus status The ZitiStatus representing the outcome of the write operation. System.Byte [] data A buffer representing the data that was received over the Ziti network. Data will always start at postiion 0. System.Int32 count The number of bytes received in this interation. Data will always start at postiion 0."
  },
  "api/csharp/NetFoundry.ZitiException.html": {
    "href": "api/csharp/NetFoundry.ZitiException.html",
    "title": "Class ZitiException | NetFoundry Ziti",
    "keywords": "Class ZitiException Represents a Ziti-specific exception Inheritance System.Object System.Exception ZitiException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiException : Exception, ISerializable Constructors | Improve this Doc ZitiException(String) The basic constructor for creating a ZitiException Declaration public ZitiException(string message) Parameters Type Name Description System.String message The message Implements System.Runtime.Serialization.ISerializable"
  },
  "api/csharp/NetFoundry.Ziti.html": {
    "href": "api/csharp/NetFoundry.Ziti.html",
    "title": "Class Ziti | NetFoundry Ziti",
    "keywords": "Class Ziti A collection of static helper methods and properties for Ziti. Inheritance System.Object Ziti Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class Ziti Properties | Improve this Doc OutputDebugInformation A property which controls whether or not output is sent to the System.Diagnostics.Debug output stream. This is a global flag - when toggled all debug messages will show across any connection. Declaration public static bool OutputDebugInformation { get; set; } Property Value Type Description System.Boolean Methods | Improve this Doc Debug(String) A helper method to output messages helpful during debugging Ziti-related issues. Declaration public static void Debug(string msg) Parameters Type Name Description System.String msg"
  },
  "api/csharp/NetFoundry.ZitiStatus.html": {
    "href": "api/csharp/NetFoundry.ZitiStatus.html",
    "title": "Enum ZitiStatus | NetFoundry Ziti",
    "keywords": "Enum ZitiStatus An enum representing the outcome of the given Ziti operation. Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public enum ZitiStatus Fields Name Description CONFIG_NOT_FOUND A user error indicating the provided configuration file was not found. CONNABORT An exceptional situation indicating the connection between the client and the Ziti Network Gateway was interrupted CONTROLLER_UNAVAILABLE A network error indicating the Ziti Network Controller was not able to be contacted. EOF A normal status indicating the connection is closed. GATEWAY_UNAVAILABLE A network error indicating the Ziti Network Gateway was not able to be contacted. NOT_AUTHORIZED A user error indicating the identity from the provided configuration file is not authorized to perform the action. OK Indicates a successful outcome SERVICE_UNAVALABLE A user error indicating the service name provided was not available. Either it does not exist or the provided identity does not have sufficient rights to the service. TIMEOUT An exceptional status indicating the operation did not complete within the specified timeout"
  },
  "ziti/clients/ios.html": {
    "href": "ziti/clients/ios.html",
    "title": "iOS | NetFoundry Ziti",
    "keywords": "iOS The iOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "ziti/clients/how-to-choose.html": {
    "href": "ziti/clients/how-to-choose.html",
    "title": "Choosing a Ziti Client | NetFoundry Ziti",
    "keywords": "Choosing a Ziti Client After creating a Ziti Network you will quickly find the need for a client that can connect directly to the overlay. There are two types of clients for Ziti Networks: SDK-based and Tunneler-based. Which client is right for you is a relatively straightforward question to answer."
  },
  "api/rest/index.html": {
    "href": "api/rest/index.html",
    "title": "| NetFoundry Ziti",
    "keywords": "this is the landing page for rest"
  },
  "ziti/install/edge-router.html": {
    "href": "ziti/install/edge-router.html",
    "title": "Edge Router | NetFoundry Ziti",
    "keywords": "Edge Router The Edge Router is responsible for the"
  },
  "ziti/manage/edge-router.html": {
    "href": "ziti/manage/edge-router.html",
    "title": "Edge Router | NetFoundry Ziti",
    "keywords": "Edge Router The Edge Router is responsible for the"
  },
  "ziti/manage/controller.html": {
    "href": "ziti/manage/controller.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Hi from the controller file configuration: what does the version mean in config file configuration: why is there a 'db' in the config and why isn't it postgres configuration: logging explain - level/format control section:"
  },
  "ziti/services/overview.html": {
    "href": "ziti/services/overview.html",
    "title": "Ziti Serivces | NetFoundry Ziti",
    "keywords": "Ziti Serivces This is all about Services"
  },
  "ziti/clients/tunneler-overview.html": {
    "href": "ziti/clients/tunneler-overview.html",
    "title": "| NetFoundry Ziti",
    "keywords": "A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. NetFoundry provides tunnelers for each major operating system. Windows MacOS Linux"
  },
  "ziti/clients/overview.html": {
    "href": "ziti/clients/overview.html",
    "title": "Clients overview | NetFoundry Ziti",
    "keywords": "Clients overview"
  },
  "ziti/clients/macos.html": {
    "href": "ziti/clients/macos.html",
    "title": "MacOS | NetFoundry Ziti",
    "keywords": "MacOS The MacOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "ziti/services.html": {
    "href": "ziti/services.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Some services deets"
  },
  "ziti/intro.html": {
    "href": "ziti/intro.html",
    "title": "| NetFoundry Ziti",
    "keywords": "HI"
  },
  "ziti/manage/router.html": {
    "href": "ziti/manage/router.html",
    "title": "| NetFoundry Ziti",
    "keywords": "the router file is here"
  },
  "ziti/appwans/overview.html": {
    "href": "ziti/appwans/overview.html",
    "title": "Ziti AppWANs | NetFoundry Ziti",
    "keywords": "Ziti AppWANs This is all about AppWANs"
  },
  "ziti/identities/enrolling.html": {
    "href": "ziti/identities/enrolling.html",
    "title": "Enrolling an Identity | NetFoundry Ziti",
    "keywords": "Enrolling an Identity This is all about enrolling identities"
  },
  "ziti/clients/which-client.html": {
    "href": "ziti/clients/which-client.html",
    "title": "Choosing a client | NetFoundry Ziti",
    "keywords": "Choosing a client Once you have a Ziti Network - you are going to require a Ziti-aware client in order to access the network. There are two types of clients and depending on your needs you'll choose to either use a tunneler or you will use an SDK to securely access the Ziti Network. Choosing which type of client you will use to connect to a Ziti Network is a straightfoward process and comes down to a single question. If you are you installing Ziti in front of an existing application which has already been developed and deployed you need to use a tunneler . If you are developing a new product, starting from scratch and you want to take advantage of a fully zero-trust solution you will probably want to use an SDK. Tunnelers A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. NetFoundry provides tunnelers for each major operating system. Windows MacOS Linux Read more on using tunnelers here SDK If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/install/pki.html": {
    "href": "ziti/install/pki.html",
    "title": "| NetFoundry Ziti",
    "keywords": "this is install/pki - unreferenced"
  },
  "ziti/clients/sdks.html": {
    "href": "ziti/clients/sdks.html",
    "title": "Ziti SDKs | NetFoundry Ziti",
    "keywords": "Ziti SDKs If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/clients/sdk-quickinfo.html": {
    "href": "ziti/clients/sdk-quickinfo.html",
    "title": "| NetFoundry Ziti",
    "keywords": "If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/quickstart.html": {
    "href": "ziti/quickstart.html",
    "title": "Ziti Quickstart | NetFoundry Ziti",
    "keywords": "Ziti Quickstart This guide will get you up and running with a demonstrable service in only a few minutes. If you are unfamiliar with the relevant ziti concepts refer to the overview . From Nothing to Network To get started with Ziti here are the steps you will need to accomplish: Get Ziti Obtain, then change the default password Create an Identity Enroll the Identity Setup your first Network Start Ziti Getting Started in AWS This guide will leverage an Amazon Machine Image (AMI) delivered via the AWS Marketplace . Using the image you will have an instance of Ziti to use as you please within minutes. If you are unfamiliar AWS you'll want to take some time to come up to speed. You will need an account, and you'll want to become familiar with the console. Start here and when you feel ready - come back to this guide. Starting a Ziti Instance NetFoundry has provided an Amazon Machine Image (AMI) delivered via the AWS Marketplace to make it easy for you to deploy a fully functional Ziti-based network. Follow the prompts and launch a new AMI. You will need to make a few key decisions that might affect your Ziti-based network. Important This is IMPORTANT. Make sure you consider and understand any security implications of the choices made when starting the AMI Virtual Private Cloud (VPC): for the instance to be put into. Choosing the VPC will determine what network resources are available to your Ziti network Subnet: The subnet you choose further defines what resources the instance will have access to. If you have a service that is not visible to the public internet and you wnat to use Ziti to secure that service make sure you put the Ziti instance on the proper subnet Security Group: You will want to put the Ziti instance into a security group that allows access from the public internet on ports: 22, 443, 1280, 3022. port 22 - the default port that ssh uses. This is how you will log into the bare AMI after it is launched. port 443 - a small UI is delivered via a web server that runs on port 443, using self-signed certificates port 1280 - the preselected port the Ziti controller will serve its API over port 3022 - the preselected port for data channels to the Ziti Edge Router Important Make sure you have the private key corresponding to the public key you choose. Without the private key - you will not be able to authenticate to the bare AMI. Obtain and Change the Default Password When first launched - the AMI will deposit a file into the file system at ~/.config/ziti/ziti-controller/credentials.json. Note Since this is your first Ziti deployment this system is expected to be transient. If the IP address or DNS entry changes (such as a system reboot) the image needs to be reconfigured becuase the certificates will no longer be valid. This file is used to reconfigure the system in this event and it happens automatically on startup. Now, ssh to the newly created machine. Once there you can obtain the username and password for your Ziti controller by issuing this command: jq -r .password ~/.config/ziti/ziti-controller/credentials.json You can choose to keep this password or change it to something easier to remember. If you change the password, please remember to use a strong password which is not easy to guess. Tip Once the password is changed - update the credentials.json file with the current password if you want the system to automatically update the certificates in the event of the image losing its IP address or DNS entry. Change via UI Change via CLI These AMIs will be provided with a self-signed certificate generated during securely during the bootup process. See changing pki for more information. Log into the UI using the password obtained in the prior step In the lower left corner, click the icon that looks like a person and choose \"Edit Profile\" Enter the current password along with a new/confirmed password and click \"Save\" To change the administrator password using the CLI simply issue these two commands: #load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) Note You will need to login one time in order to use the ziti cli: ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge controller login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert #update the admin user. This command will prompt you to enter the password ziti edge controller update authenticator updb -s Create an Identity All connections to Ziti are mutually authenticated TLS connections. Identites map a given certificate to an identity within the Controller. Read more about Identities here Creating an identity via the UI or CLI is easy: New Identity via UI New Identity via CLI On the left side click \"Edge Identities\" In the top right corner of the screen click the \"plus\" image to add a new identity Enter the name of the identity you would like to create Choose the type: Device, Service, User (choose User for now) Click save To change the administrator password using the CLI simply issue these two commands: #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt Enroll the New Identity Identities are not truly enabled until they are enrolled. Enrollment is a complex process. NetFoundy has created a tool specifically for this task to ensure safe and secure enrollment of identities. Download the enroller for your operating system. Download the jwt from the UI by clicking the icon that looks like a certificate (save the file as NewUser.jwt) or if you used the CLI from the output location specified when creating the user. In a command line editor, change to the folder containing the jwt. Enroll the identity by running ziti-enroller --jwt NewUser.jwt The ziti-enroller will output a new json file named NewUser.json . This file is precious and must be protected as it contains the identity of the given user. Create a Service With an identity created it's now time to create a service. Read more about Services here . For this example we are going to choose a simple website that is available on the open internet . This site will return the IP address you are coming from. Click this link now and discover what the your external IP is. New Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Enter \"ethzero-ui\" Enter a host name for the service. Enter \"ethzero.ziti.ui\" Enter port 80 Choose Router \"ziti-gw01\" For Endpoint Service choose: protocol = tcp host = eth0.me port = 80 Select \"demo-c01\" for the cluster Leave Hosting Identities as is Click save To change the administrator password using the CLI simply issue these two commands: #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create service ethzero-cli \"ethzero.ziti.cli\" \"80\" \"$edgeRouter\" \"tcp:eth0.me:80\" -c \"$cluster\" Create an AppWan AppWANs are used to to authorize identities to services and allow you to choose the terminating node for traffic destined to your service. Read more about appwans here New Service via UI New Service via CLI On the left side nav bar, click \"AppWANs\" In the top right corner of the screen click the \"plus\" image to add a new AppWAN Choose a name for the AppWAN. Enter \"my-first-appwan\" Choose the service(s) you want to add to the AppWAN. Make sure you pick ethzero-ui Choose the identity you created before (NewUser) Click save To create an AppWAN using the CLI issue the following commands: #load the identity's id into an environment variable identity=$(ziti edge controller list identities | grep NewUser | cut -d \" \" -f2) #load the service id into an environment variable service=$(ziti edge controller list services | grep ethzero-cli | cut -d \" \" -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create app-wan my-first-cli-appwan -i $identity -s $service Test It Ok, you're almost ready to test your Ziti setup! Now you need to acquire a pre-built client from NetFoundry. The simplest way to test your setup is to get the ziti-tunnel for your OS. The ziti-tunnel has a mode which acts as a proxy into the Ziti overlay network. You will need the enrolled identity json file created in the previous step and this will require running a command. Here are the steps to verify your Ziti network and configuration are all working properly: Open a command prompt ensure ziti-tunnel and NewUser.json are in the same directory and cd to this directory run the ziti-tunnel in proxy mode: ziti-tunnel proxy -i NewUser.json ethzero-ui:1111 ziti-tunnel proxy -i NewUser.json ethzero-cli:2222 navigate your web browser to (or use curl) to obtain your IP address by going to http://localhost:1111/ At this point you should see the external IP address of your Amazon instance. Delivered to your machine safely and securely over your Ziti network."
  },
  "ziti/overview.html": {
    "href": "ziti/overview.html",
    "title": "Overview | NetFoundry Ziti",
    "keywords": "Overview Why Ziti? Ziti represents the next generation of secure networking for your applications and has arrived with the Ziti platform, created by NetFoundry, Inc ! The Ziti Controller and the Ziti Edge Router combine to form a secure, Zero Trust entry point into your network or as a secure zero-trust proxy to other hosted services. Getting started with Ziti If you are looking to jump right in feet first you can follow along this with our up-and-running quickstart guide . The quickstart will leverage Amazon Web Services (AWS) and will have you launch an AMI which will get you up and running in no time. This environment is perfect for evaluators to get to know Ziti and the capabilities it offers. The environement was not designed for large scale deployment or for long-term usage. If you are looking for a managed service to help you run a truly global, scalable network browse over to our website at http://netfoundry.io to learn more. Overview of a Ziti Network The Ziti Network (Ziti) is composed of the following building blocks: Controller, Router, Edge Router, Edge Clients. These components are used in conjunction to provide secure connectivity between two points such as a client to a server. This type of network is considered an overlay network because it provides secure connectivity on top – or “overlaying” – existing networking infrastructure. Here's an overview of a network: ZITI CONTROLLER The NetFoundry Ziti Controller is the central function of the NetFoundry Ziti Network. The Controller provides the configuration plane. It is responsible for configuring Ziti services as well as being the central point for managing the identities used by users, devices and the nodes making up the Ziti Network. Lastly but critically, the Controller is responsible for authentication and authorization for every connection in the Ziti network. The Controller must be configured with public key infrastructure (pki). The configured pki is used to create secure, mutually authenticated TLS (mTLS) network connections between any two pieces of the Ziti Network. The Controller does not provide its own pki but for the Controller to sign certificate requests (CSR) the Controller will need to be configured with a key and certificate used for signing. (Optionally, the Ziti CLI can be used to generate a pki if needed) The controller also supports using a third-party pki should the operator of the Ziti Network have an existing pki they wish to reuse. Utilizing a third-party CA pushes the burden of obtaining and distributing properly signed certificates to the operator of the Ziti network but for sophisticated customers this might make overall management of the network easier. The Controller uses an out of process database (Postgres) to store the information needed to manage the network. ZITI FABRIC ROUTER Ziti Fabric Routers are the fundamental building blocks of the Ziti Network. These routers are responsible for securely and reliably delivering traffic from one Ziti Network node to the traffic’s destination. Fabric Routers are linked together to form a mesh network. This mesh is constantly being monitored for latency and the fastest paths are used when routing traffic to the destination. The monitoring also allows for active failover to ensure a reliable network connection even in the case of a node failure. ZITI EDGE ROUTER Another fundamental building block of the Ziti Network is the Edge Router. The Edge Router is the entry point for Edge Clients connecting to the Ziti Network. The Edge Router is a specialized Router incorporating the functionality of a Router to enable it to route traffic over the Ziti network as a Router would to a given destination. The Edge Router in combination with the Controller is responsible for authenticating and authorizing Ziti Edge Clients. ZITI EDGE CLIENTS Connecting to the Ziti Network requires a Ziti Edge Client. Edge Clients are designed to work with both brownfield and greenfield applications. If the solution being developed includes developing new software NetFoundry offers SDKs targeting various languages and runtimes to provide fast, reliable and secure connectivity. These SDKs provide the capabilities needed to securely connect to the Ziti Network and are designed to be easily incorporated into the target application. When adding secure connectivity to an already existing solution NetFoundry offers specialized Edge Clients called tunnelers which provide seamless, secure connectivity and do not require changes to the target application. USING ZITI Once the Ziti Network is established and deployed the next step is to configure the software-powered network. The three main concepts necessary to configure a Ziti Network are: Identities, Services, and AppWANs. SERVICES A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. A Ziti Service is defined by a strong, extensible identity, rather than by an expression of an underlay concept. This means that services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti Service is defined by a name and/or a certificate, rather than by a DNS name or an IP address (underlay concepts). Services also declare a node where traffic that exits the Ziti Network needs to be sent do before exiting. It’s possible for the node traffic enters to be the same it exits and it’s possible for traffic needing to traverse the Ziti Network Routers to reach the correct node. Simply specifying the node is all the end-user need do, the Ziti Network handles the rest. IDENTITIES Identities represent individual endpoints in the Ziti Network which can establish connectivity. All connections made within the Ziti Network are mutually authenticated using X509 Certificates. Every Identity is mapped to a given certificate’s signature. Ziti Edge Clients present this certificate when initiating connections to the Ziti Network. The presented certificate is used by the Ziti Network to authorize the client and enumerate the services the Identity is authorized to use. AppWAN The AppWAN is concept created to encapsulate the mapping between services and identities in a software-powered network. In the simplest terms, AppWANs are a group of services and a group of identities. The act of adding a service to an AppWAN will grant the identities in that AppWAN access to the given service. Similarly adding an identity to an AppWAN will grant that identity access to the services mapped in that AppWAN."
  },
  "ziti/cli-snippets/create-identity.html": {
    "href": "ziti/cli-snippets/create-identity.html",
    "title": "| NetFoundry Ziti",
    "keywords": "#creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt"
  },
  "ziti/install/overview.html": {
    "href": "ziti/install/overview.html",
    "title": "Installation Steps | NetFoundry Ziti",
    "keywords": "Installation Steps Installing a Ziti Network from scratch, like anything, is easy once you know how. Getting to knowing how can take some time. The goal of these pages are to get you from nothing to network the long way. If you want to take the quick route you should stop now and follow the quickstart instead. It is designed to get a Edge-only Ziti network running in no time. A basic Edge-only Ziti Network is composed of two (or three depending on how you count the database) pieces. The Controller and the Edge Router. Controller Prerequisite - Database There are a few prerequisites necessary before being able to deploy your first Controller. The first thing you will need is a database. At this time the Ziti Controller is using a Postgres instance. Setting up and managing a Postgres database is a complex task beyond the scope of this guide. This guide is intended to be illustrative of installing and managing the Ziti Controller and not maintaining a Postgres installation. Refer to the documentation from Postgres for asistance setting up a Postgres database. Prerequistie - PKI Public Key Infrastructure (PKI) is a complex topic. Edge Router"
  },
  "ziti/identities/overview.html": {
    "href": "ziti/identities/overview.html",
    "title": "Ziti Identities | NetFoundry Ziti",
    "keywords": "Ziti Identities Ziti is built on the foundation of zero-trust. A solid pillar of that foundation requires that all connections in a Ziti-enabled network are authenticated. Identities are the basis for Ziti authentication. All devices connecting to a Ziti network will have an Identity which is presented at the time of a connection being established by both the device initiating the connection and the device receiving the incoming connection. Ziti implements mutual TLS in order to authenticate both sides of a connection. Conceptually an identity can be thought of as congruent to a user account. Identities are logical entities stored inside the Ziti Controller which map an X509 certifcate to a particular named identity. Identities exist not only to authenticate connections but are also used to authorize identities within Ziti. See AppWANs for more information on authoriziation of identities. Creating an Identity The mechanism for creating identities is influenced by how your Ziti network is setup, specifically how the PKI is established. Identities are itegrally linked to the PKI configured in a given Ziti network and directly affects how identites are created. There are generally three groups of identities which can be created: One Time Token (ott) identites using the configured PKI One Time Token (ott) identites using a 3rd Party CA 3rd Party auto-enrolled identities One Time Token (OTT) One time token identities are the type of identities available to all Ziti networks. A one time token identity will have a token generated at the time of the identity's creation. This token is then submitted at some point in the future as part of the enrollment process. Once an identity is successfully enrolled - the one time token is no longer valid and cannot be used to enroll the same identity again. One time tokens are delivered from the Ziti Controller as a jwt and the token expires 24 hours after the identity is created. The token is downloadable via the basic UI provided in the Ziti Edge - Developer Edition . After you create a user you can go to the Identities page and click the icon that looks like a certificate to download the .jwt file. You can also create a one time token identity using the ziti cli tool available on the path of the Ziti Edge - Developer Edition . This command will create a new identity and output the jwt to the selected path. You can then transfer the .jwt file to its intended destination. #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt 3rd Party CA - Overview It's possible that your organization wants to reuse an existing PKI rather than to incorporate a new PKI for Ziti-powered networks. If you have an existing PKI setup you wish to reuse or if you are just interested in learning how to use a 3rd Party CA this section is for you. Note Reusing a PKI is not a simple topic and managing and maintaining a PKI is out of the scope of this guide. A 3rd Party CA will need to be created and the public certificate uploaded into the Ziti Controller. After using an existing PKI to reuse/generate a certificate, the Ziti Controller will be to create identities which will be expected to present a certificate during the connection process that is valid per the provided certificate. Adding a 3rd Party CA to the Ziti Controller Adding a certifate to the Ziti Controller is easy using the Ziti Console provided in the Ziti Edge - Developer Edition . New CA via UI New CA via REST On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format { \"name\": \"${ca_name}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${cert}\" } 3rd Party CA - One Time Token 3rd Party CA - Auto Enrolled Enrolling an Identity This is all about enrolling identities"
  },
  "ziti/identities/creating.html": {
    "href": "ziti/identities/creating.html",
    "title": "Creating an Identity | NetFoundry Ziti",
    "keywords": "Creating an Identity The mechanism for creating identities is influenced by how your Ziti network is setup, specifically how the PKI is established. Identities are itegrally linked to the PKI configured in a given Ziti network and directly affects how identites are created. There are generally three groups of identities which can be created: One Time Token (ott) identites using the configured PKI One Time Token (ott) identites using a 3rd Party CA 3rd Party auto-enrolled identities One Time Token (OTT) One time token identities are the type of identities available to all Ziti networks. A one time token identity will have a token generated at the time of the identity's creation. This token is then submitted at some point in the future as part of the enrollment process. Once an identity is successfully enrolled - the one time token is no longer valid and cannot be used to enroll the same identity again. One time tokens are delivered from the Ziti Controller as a jwt and the token expires 24 hours after the identity is created. The token is downloadable via the basic UI provided in the Ziti Edge - Developer Edition . After you create a user you can go to the Identities page and click the icon that looks like a certificate to download the .jwt file. You can also create a one time token identity using the ziti cli tool available on the path of the Ziti Edge - Developer Edition . This command will create a new identity and output the jwt to the selected path. You can then transfer the .jwt file to its intended destination. #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt 3rd Party CA - Overview It's possible that your organization wants to reuse an existing PKI rather than to incorporate a new PKI for Ziti-powered networks. If you have an existing PKI setup you wish to reuse or if you are just interested in learning how to use a 3rd Party CA this section is for you. Note Reusing a PKI is not a simple topic and managing and maintaining a PKI is out of the scope of this guide. A 3rd Party CA will need to be created and the public certificate uploaded into the Ziti Controller. After using an existing PKI to reuse/generate a certificate, the Ziti Controller will be to create identities which will be expected to present a certificate during the connection process that is valid per the provided certificate. Adding a 3rd Party CA to the Ziti Controller Adding a certifate to the Ziti Controller is easy using the Ziti Console provided in the Ziti Edge - Developer Edition . New CA via UI New CA via REST On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format { \"name\": \"${ca_name}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${cert}\" } 3rd Party CA - One Time Token 3rd Party CA - Auto Enrolled"
  },
  "api/rest/create-ca-json.html": {
    "href": "api/rest/create-ca-json.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format { \"name\": \"${ca_name}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${cert}\" }"
  }
}